
        /*

        // setup everything related to the debug-mode
        if(AppSnakeFX.inDebugMode){

            // we gonna be gentle to the cpu
            if(DEBUG_LOWCORE){
                numPlayers = 3;
            }

            // we gonna stress test the cpu
            if(DEBUG_HARDCORE){
                numPlayers = 20;
            }

            // generate the players related to low or hardcore
            if(DEBUG_LOWCORE || DEBUG_HARDCORE){
                for (int i = 0; i < numPlayers; i++) {
                    int newY = i % 4 * 3 + 3;
                    int newX = i / 4 * 5 + 3;
                    snakeList.add (
                        new Snake (new Vector2(newX, newY),Color.color(Math.random(), Math.random(), Math.random()))
                    );
                }
            }

            // we want to play alone
            if(DEBUG_SINGLEPLAYER){
                snakeList.add ( new Snake ( new Vector2(5,5), Color.PURPLE));
            }

            // every snake is controlled by random keystrokes or some pattern
            if(DEBUG_EVERYBODY_NPC){
                for (Snake snake : snakeList) {
                    snake.isNPC = true;
                }
            }

            */

        /*
        // Normal mode
        } else {

        }
        */

        /*
        // setup everything related to the debug-mode
        if(AppSnakeFX.inDebugMode){

            // we gonna be gentle to the cpu
            if(DEBUG_LOWCORE){
                numPlayers = 3;
            }

            // we gonna stress test the cpu
            if(DEBUG_HARDCORE){
                numPlayers = 20;
            }

            // generate the players related to low or hardcore
            if(DEBUG_LOWCORE || DEBUG_HARDCORE){
                for (int i = 0; i < numPlayers; i++) {
                    int newY = i % 4 * 3 + 3;
                    int newX = i / 4 * 5 + 3;
                    snakeList.add (
                            new Snake (new Vector2(newX, newY),Color.color(Math.random(), Math.random(), Math.random()))
                    );
                }
            }

            // we want to play alone
            if(DEBUG_SINGLEPLAYER){
                snakeList.add ( new Snake ( new Vector2(5,5), Color.PURPLE));
            }

            // every snake is controlled by random keystrokes or some pattern
            if(DEBUG_EVERYBODY_NPC){
                for (Snake snake : snakeList) {
                    snake.isNPC = true;
                }
            }

            // Normal mode
        } else {
            // regular game-play
            // TODO: these values need to get retrieved from the backend
            numPlayers = 1;
            Color[] playerColors = {Color.PURPLE, Color.BLUE, Color.RED, Color.GREEN};
            for (int i = 0; i < numPlayers; i++) {
                snakeList.add ( new Snake ( new Vector2(0, 5 * i), playerColors[i]));
            }
        }
        */




    private void drawIndices(GraphicsContext gc) {
        gc.setFont(arial10);
        int tileSize = config.tileSize;
        int halfTileSize = config.tileSize / 2;
        for (int y = 0; y < config.rows; y++) {
            for (int x = 0; x < config.columns; x++) {
                gc.fillText("(" + x + "," + y + ")", x * tileSize , y * tileSize + halfTileSize);
            }
        }
    }


    private void drawDirections(GraphicsContext gc) {
        if(DEBUG_DRAW_DIRECTIONS){
            int tileSize = config.tileSize;
            int halfTileSize = tileSize / 2;
            for (Snake snake : snakeList) {
                Vector2 current = snake.head;
                Vector2 next = new Vector2(current).add(snake.currentDirection);

                gc.setLineWidth(10);
                gc.setStroke(Color.GREEN);
                gc.strokeLine(
                        current.x * tileSize + halfTileSize,
                        current.y * tileSize + halfTileSize,
                        next.x    * tileSize + halfTileSize,
                        next.y    * tileSize + halfTileSize
                );
            }
        }
    }


        // Instead of going game over when hitting a wall you can also use a wallteleport
        /*
        public checkWallTeleport();
        ...
        public void checkWallTeleport() {

            // check for wall collision
            for (Snake snake : snakeList) {

                if (snake.head.x < 0){
                    snake.head.x = config.rows;
                }
                else if (snake.head.y < 0){
                    snake.head.y = config.rows;
                }
                else if (snake.head.x > config.rows){
                    snake.head.x = 0;
                }
                else if (snake.head.y > config.columns) {
                    snake.head.y = 0;
                }
        */